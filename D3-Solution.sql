-- Concepts:
-- 1
-- A JOIN is more efficient in most cases, but there are cases in which 
-- unwanted GROUP BYs need to be implemented because of usage of aggegate methods
-- in SELECT clause, in this case, subqueries can help improve performance by eliminating unwanted GROUP BYs.

-- 2
-- A Common Table Expression, also called as CTE in short form, 
-- is a temporary named result set that you can reference within 
-- a SELECT, INSERT, UPDATE, or DELETE statement. 
-- The CTE can also be used in a View.

-- 3
-- Temporary tables are defined just like regular tables, only they are automatically stored in the tempdb database.
-- Temporary table types: 
-- Local: Local temporary tables are prefixed with a single # sign.
-- Global: global temporary tables with a double ## sign.
-- Local temporary tables are available for use by the current user connection that created them.
-- Once a connection creates a global temporary table, any user with proper permissions access 
-- to the current database they are in have access to the table. 

-- 4
-- Truncate reseeds identity values, whereas delete doesn't.
-- Truncate removes all records and doesn't fire triggers.
-- Truncate is faster compared to delete as it makes less use of the transaction log.
-- Truncate is not possible when a table is referenced by a Foreign Key or tables are 
-- used in replication or with indexed views.

-- 5
-- An Identity column is a column (also known as a field) in a database table that 
-- is made up of values generated by the database. 
-- Truncate reseeds identity values, whereas delete doesn't.

-- 6
-- Same as question 4

-- Queries:
USE Northwind
SET STATISTICS IO ON

-- 1
SELECT c.City
FROM 
(SELECT DISTINCT City FROM dbo.Customers) c
INNER JOIN 
(SELECT DISTINCT City FROM dbo.Employees) e
ON c.City = e.City

-- Compare performance
SELECT DISTINCT c.City
FROM dbo.Customers c
INNER JOIN dbo.Employees e
ON c.City = e.City

-- 2
-- a
SELECT DISTINCT c.City
FROM dbo.Customers c
WHERE c.City
NOT IN (SELECT DISTINCT City    
-- (Can NOT use = ) Subquery returned more than 1 value. Not permitted when the subquery 
-- follows =, !=, <, <= , >, >= or 
-- when the subquery is used as an expression.
FROM dbo.Employees)

SELECT DISTINCT c.City
FROM dbo.Customers c
WHERE NOT EXISTS 
(SELECT City
FROM dbo.Employees 
WHERE c.City = City)

-- b
SELECT DISTINCT c.City
FROM dbo.Customers c
LEFT JOIN dbo.Employees e
ON c.City = e.City
WHERE e.EmployeeID IS NULL

-- 3
SELECT p.ProductName, q.Quantity
FROM dbo.Products p
INNER JOIN 
(SELECT SUM(Quantity) Quantity, od.ProductID
FROM dbo.[Order Details] od
GROUP BY od.ProductID) q
ON p.ProductID = q.ProductID

-- 4
-- Join of 4 tables: Customers, Products, Orders, Order Details
SELECT c.City, cpq.ProductName, SUM(cpq.Quantity)
FROM dbo.Customers c
INNER JOIN (SELECT p.ProductName, cq.CustomerID, cq.Quantity
FROM dbo.Products p
INNER JOIN (SELECT SUM(q.Quantity) Quantity, q.CustomerID, q.ProductID
FROM (SELECT o.CustomerID, od.ProductID, od.Quantity
FROM dbo.Orders o
INNER JOIN dbo.[Order Details] od
ON o.OrderID = od.OrderID) q
GROUP BY q.CustomerID, q.ProductID) cq
ON cq.ProductID = p.ProductID) cpq
ON c.CustomerID = cpq.CustomerID
GROUP BY c.City, cpq.ProductName
ORDER BY c.City

-- 5
-- a
WITH CTE 
AS 
(SELECT COUNT(1) CustomerCount, City
FROM dbo.Customers
GROUP BY City
HAVING COUNT(1) >= 2)

SELECT DISTINCT CTE.City
FROM CTE
WHERE CTE.CustomerCount = 2
UNION
SELECT DISTINCT CTE.City
FROM CTE
WHERE CTE.CustomerCount > 2

-- b
SELECT DISTINCT c.City 
FROM dbo.Customers c
INNER JOIN
(SELECT COUNT(CustomerID) CustomerCount, City
FROM dbo.Customers
GROUP BY City
HAVING COUNT(CustomerID) >= 2) c2
ON c.City = c2.City

-- Incorrect solution:
-- Just only select all distinct cities from c
-- SELECT DISTINCT c.City 
-- FROM dbo.Customers c
-- WHERE EXISTS 
-- (SELECT COUNT(CustomerID) CustomerCount, City
-- FROM dbo.Customers
-- GROUP BY City
-- HAVING COUNT(CustomerID) >= 2)

SELECT DISTINCT c.City 
FROM dbo.Customers c
WHERE EXISTS        -- When using EXISTS, column of outer table must be included in subquery
(SELECT COUNT(CustomerID) CustomerCount, City
FROM dbo.Customers
WHERE c.City = City     -- WHERE needs to be stated before GROUP BY
GROUP BY City
HAVING COUNT(CustomerID) >= 2)

-- Incorrect solution:
-- Only one expression can be specified in the select list when the subquery is not introduced with EXISTS.
-- SELECT DISTINCT c.City 
-- FROM dbo.Customers c
-- WHERE c.City
-- IN (SELECT COUNT(CustomerID) CustomerCount, City
-- FROM dbo.Customers
-- GROUP BY City
-- HAVING COUNT(CustomerID) >= 2)

SELECT DISTINCT c.City 
FROM dbo.Customers c
WHERE c.City
IN (SELECT vc.City FROM 
(SELECT COUNT(CustomerID) CustomerCount, City
FROM dbo.Customers
GROUP BY City
HAVING COUNT(CustomerID) >= 2) vc)

-- Incorrect solution:
-- City in subquery is not specified
-- SELECT DISTINCT c.City 
-- FROM dbo.Customers c
-- WHERE c.City
-- IN (SELECT City 
-- FROM (SELECT COUNT(CustomerID) CustomerCount, City
-- FROM dbo.Customers
-- GROUP BY City
-- HAVING COUNT(CustomerID) >= 2))

-- 6
WITH cte
AS (
    SELECT o.ShipCity, p.ProductID
    FROM dbo.Orders o
    INNER JOIN
    dbo.[Order Details] od
    ON o.OrderID = od.OrderID
    INNER JOIN dbo.Products p
    ON od.ProductID = p.ProductID
)
SELECT cte.ShipCity City, COUNT(cte.ProductID) ProductKindNumber
FROM cte
GROUP BY cte.ShipCity
HAVING COUNT(cte.ProductID) >= 2

WITH cte   
AS (
    SELECT o.ShipCity, COUNT(p.ProductID) ProductKindNumber      -- cte MUST have specified column names
    FROM dbo.Orders o
    INNER JOIN
    dbo.[Order Details] od
    ON o.OrderID = od.OrderID
    INNER JOIN dbo.Products p
    ON od.ProductID = p.ProductID
    GROUP BY o.ShipCity
    HAVING COUNT(p.ProductID) >= 2    
    -- Can NOT use alias from AGG func in HAVING statement (alias creation is executed in the very end)
    -- Can NOT use ORDER BY in CTE_query_definition except when a TOP clause is specified
)
SELECT cte.ShipCity City
FROM cte


WITH oq AS    -- No need to specify column name when it can be inherited from result set created by select statement
(
    SELECT o.CustomerID, od.ProductID, od.Quantity
    FROM dbo.Orders o
    INNER JOIN dbo.[Order Details] od
    ON o.OrderID = od.OrderID
), 
oc AS 
(
    SELECT c.CustomerID, o.OrderID, c.City
    FROM dbo.Customers c
    INNER JOIN dbo.Orders o
    ON c.CustomerID = o.CustomerID
),
cq AS
(
    SELECT oc.City, oq.ProductID, SUM(oq.Quantity) Quantity     
    -- Need to specify column name when it's not specified in result set by default (e.g. use AGG functions)
    FROM oq     -- Can use CTE declared ahead or itself (recursive CTE) inside another CTE
    INNER JOIN oc
    ON oq.CustomerID = oc.CustomerID
    GROUP BY oc.City, oq.ProductID
),
pq AS 
(
    SELECT DISTINCT p.ProductID, p.ProductName
    -- Need to use DISTINCT when joining on columns having not unique values in either of them
    -- Otherwise will have duplicates in result set
    FROM dbo.Products p
    INNER JOIN dbo.[Order Details] od
    ON p.ProductID = od.ProductID
)
SELECT City, ProductName, Quantity
-- No need to specify source table for columns when no duplicates exsit in column names when joining multiple tables
FROM cq
INNER JOIN pq
ON cq.ProductID = pq.ProductID
ORDER BY City

-- CTE Can be used within ONLY ONE single SELECT, INSERT, UPDATE, DELETE, or MERGE statement
-- right after its definition.

-- 7
SELECT DISTINCT c.ContactName, c.City, o.ShipCity
FROM dbo.Customers c
INNER JOIN dbo.Orders o
ON c.CustomerID = o.CustomerID AND c.City != o.ShipCity

-- 8
WITH CustomerCity
AS (
    SELECT OrderID, City
    FROM dbo.Customers c
    INNER JOIN dbo.Orders o
    ON c.CustomerID = o.CustomerID
),
Top5Product
AS (
    SELECT TOP 5 ProductID, 
    ROUND(SUM(UnitPrice*(1-Discount)*Quantity)/SUM(Quantity), 2) AveragePrice,
    SUM(Quantity) TotalQuantity
    FROM dbo.[Order Details] od
    GROUP BY ProductID
    ORDER BY TotalQuantity
),
CityOrder
AS (
    SELECT p.ProductID, c.City, 
    SUM(Quantity) CityOrderQuantity
    FROM Top5Product p
    INNER JOIN dbo.[Order Details] od
    ON p.ProductID = od.ProductID
    INNER JOIN CustomerCity c
    ON od.OrderID = c.OrderID
    GROUP BY p.ProductID, c.City
),
RankCity
AS (
    SELECT p.ProductID, ProductName, City,
    RANK() OVER(PARTITION BY p.ProductID ORDER BY CityOrderQuantity DESC) CityRank
    FROM CityOrder c
    INNER JOIN dbo.Products p
    ON c.ProductID = p.ProductID
)
SELECT c.ProductName, p.AveragePrice, c.City
FROM RankCity c
INNER JOIN Top5Product p
ON c.ProductID = p.ProductID
WHERE c.CityRank = 1

-- 9
-- a
SELECT e.City
FROM dbo.Employees e
WHERE e.City NOT IN
(SELECT c.City
FROM dbo.Orders o
INNER JOIN dbo.Customers c
ON o.CustomerID = c.CustomerID)

-- b
WITH cte
AS (
    SELECT c.City
    FROM dbo.Orders o
    INNER JOIN dbo.Customers c
    ON o.CustomerID = c.CustomerID
)
SELECT City
FROM dbo.Employees 
WHERE City NOT IN 
(SELECT City FROM cte)

-- c USE #table
CREATE TABLE #cte 
(City VARCHAR(15))

INSERT INTO #cte
SELECT c.City
FROM dbo.Orders o
INNER JOIN dbo.Customers c
ON o.CustomerID = c.CustomerID

SELECT City
FROM dbo.Employees 
WHERE City NOT IN 
(SELECT City FROM #cte)

DROP TABLE #cte

-- 10
WITH EmployeeCity
AS (
    SELECT e.City, COUNT(o.OrderID) OrderNumber
    FROM dbo.Customers c
    INNER JOIN dbo.Orders o
    ON c.CustomerID = o.CustomerID
    INNER JOIN dbo.Employees e
    ON c.City = e.City
    GROUP BY e.City
),
OrderCity
AS (
    SELECT c.City, COUNT(o.OrderID) OrderQuantity
    FROM dbo.Orders o
    INNER JOIN dbo.Customers c
    ON o.CustomerID = c.CustomerID
    GROUP BY c.City
)
SELECT * 
FROM (SELECT TOP 1 City
FROM EmployeeCity
ORDER BY OrderNumber DESC) ec    -- MUST give subquery an alias
UNION
SELECT *
FROM (SELECT TOP 1 City
FROM OrderCity
ORDER BY OrderQuantity DESC) oc
-- Can NOT use ORDER BY within the SELECT statements of set operators
-- ORDER BY can ONLY be implemented at the very end on the result set after UNION

-- Invalid Code
-- SELECT TOP 1 City
-- FROM EmployeeCity
-- ORDER BY OrderNumber DESC
-- UNION
-- SELECT TOP 1 City
-- FROM OrderCity
-- ORDER BY OrderQuantity DESC

-- 11. How to remove the duplicates record of a table?
-- Firstly, use ROW_NUMBER() OVER(PARTITION BY all columns ORDER BY any column)
-- Then remove all records where ROW_NUMBER > 1

-- RANK() also works only if the table has a column with unique value. e.g. id/primary key
-- ROW_NUMBER() OVER(PARTITION BY all non-unique columns ORDER BY id)

-- Sample Table for 12-14
-- Employee ( empid integer, mgrid integer, deptid integer, salary integer) 
-- Dept (deptid integer, deptname text)

-- 12
SELECT l.empid
FROM Employee AS l
LEFT JOIN Employee AS r
ON l.empid = r.mgrid
WHERE r.mgrid IS NULL

-- 13
SELECT deptname, empnumber
FROM 
(SELECT deptname, COUNT(1) empnumber, RANK() OVER(ORDER BY empnumber DESC) rank
FROM Employee e
INNER JOIN Dept d
ON d.deptid = e.deptid
GROUP BY d.deptname)
WHERE rank = 1


-- Employee ( empid integer, mgrid integer, deptid integer, salary integer) 
-- Dept (deptid integer, deptname text)

-- 14
SELECT deptname, empid, salary
FROM 
(SELECT d.deptname, e.empid, e,salary, 
ROW_NUMBER() OVER(PARTITION BY d.deptname ORDER BY e.salary DESC) rank
FROM Employee e
INNER JOIN Dept d
ON e.deptid = d.deptid)
WHERE rank <= 3
ORDER BY deptname
